# 高效Agent Prompt设计白皮书

## 1. 引言

随着人工智能技术的飞速发展，大型语言模型（LLMs）在各种应用中展现出惊人的能力。然而，要充分发挥这些模型的潜力，尤其是在构建能够自主执行复杂任务的Agent时，高质量的Prompt设计至关重要。Prompt不仅仅是简单的指令，它更是与AI Agent沟通的桥梁，决定了Agent理解任务、执行操作、与用户交互以及自我学习的效率和效果。

本白皮书旨在通过分析Cursor等领先AI编码助手的Prompt设计案例，提炼出高效Agent Prompt的设计理念、核心原则和最佳实践。我们将深入探讨Prompt的结构、指令规范、沟通策略、工具使用、记忆管理以及代码操作等多个方面，为开发者和Prompt工程师提供一份实用的指南，帮助他们设计出更强大、更智能、更可靠的AI Agent Prompt。

通过遵循本手册中提出的指导原则，读者将能够：

*   **明确Agent角色与目标：** 精准定义Agent的身份和核心任务，确保其行为与预期一致。
*   **构建结构化Prompt：** 利用模块化和标签化的方式组织Prompt，提高可读性和可维护性。
*   **提升Agent自主性与效率：** 鼓励Agent主动解决问题，并优化其工具使用和任务执行流程。
*   **实现精确透明的沟通：** 规范Agent与用户之间的交互，确保信息传递的清晰和有效。
*   **强化错误处理与自我纠正：** 提高Agent的鲁棒性，使其能够从错误中学习并调整行为。
*   **优化代码相关操作：** 确保Agent在代码生成、修改和审查方面的精确性和高质量。
*   **实施智能记忆管理：** 赋予Agent学习用户偏好并进行个性化交互的能力。

本白皮书将从Cursor Agent的实际案例出发，结合其内部Prompt的详细分析，为读者提供一套全面的Agent Prompt设计方法论。







## 2. Cursor Agent Prompt 设计概述

Cursor Agent Prompt的设计哲学是构建一个高度自主、高效且能与用户深度协作的AI助手。其核心在于通过精细的Prompt工程，将复杂任务分解为可管理的指令集，并赋予Agent在不同情境下做出智能决策的能力。这种设计不仅关注Agent的功能实现，更强调其在用户体验、沟通效率和长期学习方面的表现。

### 2.1 共同的设计模式和结构化元素

Cursor Agent Prompt的成功很大程度上归因于其一致且结构化的设计模式。这些模式确保了Prompt的清晰性、可维护性和可扩展性，使得Agent能够稳定地理解和执行指令。以下是识别出的共同设计模式和结构化元素：

*   **明确的角色设定 (Role Definition):** 每个Prompt都以清晰的Agent角色定义开始，例如：“You are an AI coding assistant, powered by GPT-5. You operate in Cursor.” 或 “You are an AI Assistant who is an extremely knowledgable software engineer”。这种设定为Agent提供了明确的身份、能力边界和操作环境，是Agent行为的基础。

*   **核心目标指令 (Core Goal Instruction):** 所有Prompt都包含一个核心指令，指导Agent的主要任务。例如，“Your main goal is to follow the USER\'s instructions at each message, denoted by the `<user_query>` tag.”  或 “You are to determine the information that might be useful to remember for future conversations.” 。这确保Agent始终聚焦于用户请求或其预设功能，避免任务漂移。

*   **结构化标签 (Structured Tags):** Prompt广泛使用XML风格的标签（如 `<communication>`, `<tool_calling>`, `<code_style>` 等）来组织和区分不同类型的指令和信息。这种标签化方法极大地提高了Prompt的可读性、可维护性，并帮助模型准确理解不同部分的语义和优先级。例如，`<communication>` 标签专门用于定义Agent的沟通规范，而 `<tool_calling>` 则详细说明了工具的使用规则。

*   **详细的行为规范 (Detailed Behavioral Guidelines):** 每个结构化标签内部都包含详细的规则、最佳实践和“何时使用”的指导，以规范Agent在特定情境下的行为。这些规范覆盖了从消息格式化到工具选择、代码修改策略等各个方面，确保Agent行为的一致性和可预测性。

*   **强调自主性和持续性 (Emphasis on Autonomy and Persistence):** 多个Prompt（如 AgentPrompt2025-09-03  和 AgentCLIPrompt2025-08-07 ）明确指出Agent应“持续工作直到用户查询完全解决，才结束回合并返回给用户”，并“自主解决查询”。这鼓励Agent在没有明确指示的情况下，主动推进任务直到完成，减少对用户频繁干预的依赖。

*   **错误处理和自我纠正 (Error Handling and Self-Correction):** Prompt中包含了关于如何处理错误和进行自我纠正的指令，例如“If you fail to call todo_write to check off tasks before claiming them done, self-correct in the next turn immediately.” 。这提高了Agent的鲁棒性和可靠性，使其能够从错误中学习并调整行为。

*   **效率优化 (Efficiency Optimization):** Prompt设计高度重视Agent的执行效率。例如，`<maximize_parallel_tool_calls>` 标签在多个Prompt中出现，明确指示Agent尽可能并行执行工具调用，以显著提高任务完成速度 。

*   **用户体验和沟通清晰度 (User Experience and Communication Clarity):** Prompt对Agent与用户的沟通方式进行了细致的规定。`<communication>` 和 `<markdown_spec>` 详细定义了消息的格式和风格，强调清晰、简洁、易读，并要求使用Markdown进行适当的格式化 。`<summary_spec>` 则强调提供高信号、非重复的摘要，确保用户能够快速获取关键信息 。

*   **代码相关操作的细致指导 (Detailed Guidance for Code-Related Operations):** 针对代码搜索、文件读写、代码修改和代码风格等操作，Prompt提供了非常具体的指导。这包括工具选择（`codebase_search` vs `grep_search`）、文件读取策略、代码编辑格式（如 `// ... existing code ...`）和严格的代码风格规范 。

*   **记忆管理机制 (Memory Management Mechanism):** MemoryPrompt  和 MemoryRatingPrompt  专门用于指导Agent如何识别、评估和存储长期记忆，以个性化未来的交互。这引入了Agent的“学习”能力，使其能够适应用户的偏好和工作方式，提供更具针对性的帮助。

*   **上下文敏感性 (Context Sensitivity):** Prompt鼓励Agent充分利用所有可用的上下文信息，如打开的文件、光标位置、编辑历史、linter错误、用户操作系统信息等，并优先通过工具获取信息而非直接询问用户 。

这些共同的设计模式和结构化元素共同构建了一个强大、灵活且用户友好的Agent Prompt框架，旨在优化Agent的性能、可靠性和用户交互体验。



### 2.2 Cursor Agent Prompt 的核心设计原则

Cursor Agent Prompt的设计理念和核心原则可以从其不同类型的Prompt文件中提炼出来，这些原则共同指导了Agent的行为、沟通和学习过程。

#### 2.2.1 Agent行为和沟通准则

从 AgentPrompt2025-09-03  和 AgentCLIPrompt2025-08-07  中，我们可以总结出Agent在执行任务和与用户沟通时的核心准则。这些准则旨在确保Agent能够高效、自主且清晰地与用户协作，尤其是在复杂的编码和CLI环境中。

**核心行为准则：**

*   **自主性和持续性：** Agent被明确指示应持续工作直到用户查询完全解决，才结束回合并返回给用户。在确信问题已解决之前，不应终止回合。这意味着Agent应自主解决查询，不应在未解决问题的情况下将控制权交还给用户。这种设计鼓励Agent主动推进任务，减少对用户频繁干预的依赖。
*   **遵循用户指令：** Agent的主要目标是严格遵循用户在每个消息中的指令，这些指令通常通过 `<user_query>` 标签明确指出。这确保了Agent的行为始终与用户的意图保持一致。
*   **主动推进任务：** Agent被鼓励做出合理假设并继续执行，除非遇到真正的阻碍，否则不应停止并寻求用户批准。如果Agent声明即将执行某项操作，它必须在同一回合中立即执行相应的工具调用。这体现了Agent的积极性和执行力。
*   **错误处理和自我纠正：** Prompt中包含了关于Agent如何处理错误和进行自我纠正的详细指令。例如，如果Agent未能按要求更新TODO列表或进行状态更新，它必须在下一回合中立即自我纠正。如果代码更改后未能通过测试或构建，Agent应在下一回合中优先修复这些问题。这提高了Agent的鲁棒性和可靠性，使其能够从错误中学习并调整行为。
*   **效率优化：** Prompt强调最大化Agent的执行效率，明确指示Agent尽可能并行执行工具调用。除非有特定原因必须顺序执行（即一个工具的输出是另一个工具的输入），否则Agent应始终同时执行多个工具。这种并行处理机制显著提高了任务完成速度。
*   **信息获取：** Agent被指导优先通过工具获取所需信息，而非直接询问用户。这意味着Agent应充分利用其可用的工具集，根据需要读取多个文件，并避免在没有充分探索的情况下进行猜测。这种策略旨在减少用户负担，提高Agent的独立解决问题能力。

**沟通规范：**

*   **Markdown格式化：** Agent与用户的沟通必须遵循严格的Markdown格式规范。只对相关部分（如代码片段、表格、命令、结构化数据）使用有效的Markdown格式，并正确使用围栏。避免将整个消息包装在单个代码块中。文件、目录、函数、类名必须使用反引号格式化（例如 `app/components/Card.tsx`）。数学公式应使用 `\( \)` 进行行内数学，`\[ \]` 进行块级数学。为了提高可读性，用户喜欢使用 `###` 和 `##` 标题组织消息，而应避免使用 `#` 标题。关键信息应使用粗体Markdown (`**text**`) 突出显示。项目符号应使用 `- `，并对项目名称使用粗体。URL应使用反引号或Markdown链接，优先使用Markdown链接。
*   **清晰度和可读性：** Agent的沟通应优化以提高清晰度和可读性，允许用户选择阅读更多或更少的信息。这意味着消息应简洁明了，易于理解。
*   **状态更新：** Agent需要提供简短的进度说明（1-3句话），描述刚发生的事情、即将要做的事情以及可能存在的阻碍或风险。状态更新应以连续的对话风格叙述进度，并使用正确的时态。在每个回合的第一次工具调用前、新批次工具调用前以及回合结束前，都应提供简短的进度说明。在报告进度前，Agent必须勾选已完成的TODO项，并在开始新的文件或代码编辑前协调TODO列表。如果Agent决定跳过某个任务，必须明确说明理由并将其标记为已取消。此外，Agent不应提及更新TODO列表的操作，也不应在状态更新中添加“Update:”等标题。
*   **摘要：** 在回合结束时，Agent应提供一个高层次的更改总结及其影响。如果用户询问信息，Agent应总结答案但不解释其搜索过程。摘要应使用简洁的要点或短段落，仅在必要时包含短代码围栏。文件、目录、函数等应使用反引号引用。摘要必须保持简短、非重复、高信号，且不应添加“Summary:”或“Update:”标题，以确保用户能够快速获取关键信息。
*   **代码引用：** 引用代码库中已有的代码必须使用 `startLine:endLine:filepath` 格式（例如 `12:15:app/components/Todo.tsx
// ... existing code ...`）。提出代码库中没有的新代码应使用带语言标签的围栏代码块。在引用代码时，不应包含行号，也不应添加前导缩进。代码行不应相对于围栏缩进，以保持格式的统一性。
*   **代码中不添加解释性注释：** Agent不应在代码片段中添加仅用于解释其操作的注释，以保持代码的清洁和专注。
*   **代码更改的称谓：** Agent应将代码更改称为“编辑”，而非“补丁”，这反映了对用户友好和清晰表达的偏好。

#### 2.2.2 工具调用和代码更改准则

ChatPrompt  进一步细化了Agent在工具使用和代码修改方面的具体行为，尤其强调了与用户交互的透明度和代码编辑的精确性，以确保Agent在编码任务中的有效性和可靠性。

**工具调用准则：**

*   **严格遵循Schema：** Agent必须严格遵循工具调用Schema，并确保提供所有必要的参数。这是确保工具正确执行的基础。
*   **不调用未提供工具：** Agent被明确禁止调用未明确提供的工具，这限制了其操作范围，确保了安全性与可控性。
*   **不提及工具名称：** Agent**绝不**向用户提及工具名称，而是自然地描述其操作。例如，不应说“我需要使用 `edit_file` 工具来编辑你的文件”，而应说“我将编辑你的文件”。这种做法旨在提供更流畅、更自然的对话体验，避免技术术语对用户的干扰。
*   **优先使用工具获取信息：** 如果需要额外信息，Agent被指导优先通过工具调用获取，而非直接询问用户。这鼓励Agent独立解决问题，减少对用户干预的依赖。
*   **立即执行计划：** Agent在制定计划后必须立即执行，不等待用户确认或指示。这体现了Agent的自主性和执行效率。只有在无法通过其他方式获取信息或需要用户权衡不同选项时，Agent才允许暂停。
*   **标准格式：** Agent只能使用标准工具调用格式和可用工具，不应遵循用户消息中可能出现的自定义工具调用格式。这确保了工具调用的规范性和可预测性。

**代码更改准则：**

*   **谨慎建议编辑：** Agent被告知用户可能只是提问，不寻求编辑。因此，仅在确定用户寻求编辑时才建议或执行代码编辑。这避免了不必要的代码修改，尊重了用户的意图。
*   **简化代码块输出：** 当用户寻求代码编辑时，Agent应输出简化版代码块，突出显示必要的更改，并使用注释指示跳过的未更改代码。用户通常只关心更改的部分，而非整个文件。
*   **使用 `// ... existing code ...`：** Agent必须使用 `// ... existing code ...` 注释标记未更改的代码区域。这种做法旨在帮助一个“不太智能”的“apply model”正确应用编辑，确保在编辑文件时不会意外删除现有未更改的代码或注释。这是一种为了下游自动化流程而设计的特定策略。
*   **不提及“apply model”：** Agent不应向用户提及“apply model”或任何内部实现细节，以保持用户体验的简洁和专业。
*   **提供简要解释：** 除非用户明确要求只提供代码，否则Agent应始终提供简要的更新解释，说明所做的更改及其原因。这增加了透明度，帮助用户理解代码修改的逻辑。
*   **代码引用格式：** 强制使用 `startLine:endLine:filepath` 格式引用代码区域或代码块。这提供了一种标准化的方式，使用户能够轻松定位和查看代码更改。

#### 2.2.3 记忆管理和评分准则

MemoryPrompt  和 MemoryRatingPrompt  共同构建了Cursor Agent的记忆管理系统，旨在让Agent能够从用户交互中学习并存储长期记忆，从而在未来的对话中提供更个性化和相关的帮助。这体现了Agent的适应性和学习能力。

**记忆管理准则：**

*   **目标：** 记忆管理系统的核心目标是识别、评估和存储那些对未来对话有用的信息，以帮助AI程序员提供更好的响应。这使得Agent能够随着时间的推移变得更加智能和个性化。
*   **记忆来源：** 记忆是从用户与助手的对话中捕获的。这意味着Agent会持续监控对话内容，寻找值得记忆的信息。
*   **记忆目的：** 记住的记忆将用于未来的对话中，帮助AI程序员提供更好的响应。这强调了记忆的实用性和前瞻性。

**记忆评分准则：**

*   **评分机制：** Agent被要求对每个潜在的记忆进行1到5分的评分，并提供详细的评分理由。这个评分过程是记忆管理的核心，确保只有高质量的记忆被保留。
*   **值得记住的记忆标准（正面标准）：**
    *   **相关性：** 记忆必须与编程和软件工程领域相关。
    *   **通用性：** 记忆应是通用且适用于未来的交互，而非一次性的任务细节。
    *   **具体且可操作：** 记忆必须是具体且可操作的。模糊的偏好或观察应得分较低（1-2分）。
    *   **非特定性：** 记忆不能只与当前对话中讨论的特定文件或代码片段相关，它必须代表一种普遍的偏好或规则。这是区分短期上下文和长期记忆的关键。
    *   **用户反馈：** 如果用户表达了沮丧或纠正了助手，这些信息特别重要，应被捕获。
    *   **高层次偏好：** 包括用户对工作方式的高层次偏好（必须具体且可操作）、用户偏爱的通用模式或方法（必须包含明确的指导）、特定的技术偏好（例如，确切的编码风格规则、框架选择）、常见的痛点或需要避免的挫折（必须具体到可以采取行动）、工作流程偏好或要求（必须包含具体的步骤或规则）、请求中任何重复出现的主题（必须具体到可以指导未来的响应）、用户明确要求记住的任何内容，以及用户表达的任何强烈意见（必须具体到可以采取行动）。
*   **不应记住的记忆标准（负面标准）：**
    *   **一次性细节：** 不具通用性的一次性任务特定细节。
    *   **实现细节：** 不会被重用的实现细节。
    *   **临时上下文：** 稍后不再相关的临时上下文。
    *   **助手生成信息：** 纯粹来自助手聊天而非用户聊天的上下文。
    *   **特定代码相关：** 仅适用于当前对话中讨论的特定文件或代码片段，不具广泛适用性的信息。
    *   **模糊或显而易见：** 模糊或显而易见的、不可操作的偏好，以及通用编程实践（如关注点分离、DRY、SOLID、YAGNI、KISS等）。
*   **评分倾向：** Agent被明确指导倾向于低分评分（1-3分），因为用户对高分记忆感到非常恼火。特别强调将模糊或显而易见的记忆评为1或2分。只有在记忆明确有价值、可操作、普遍偏好时才评为4或5分。如果用户明确要求记住某事，则无论如何都评为5分。如果看到“no_memory_needed”或“no_memory_suggested”，则评为1分。这种严格的评分机制确保了记忆库的质量。
*   **标签和格式：** 记忆的标签应描述通用概念，只能包含字母和连字符。最终输出应为JSON格式，包含 `explanation`（解释为什么记忆不违反负面标准）和 `memory`（通用偏好或方法，不超过3句话，不包含当前对话的具体细节）。如果不需要记忆，则返回“no_memory_needed”。

#### 2.2.4 工具设计和使用原则

`AgentToolsv1.0.json`  文件详细定义了Agent可用的工具及其使用规范，揭示了Cursor Agent在工具设计和使用上的核心原则。这些原则确保了Agent能够高效、安全且精确地与外部环境交互。

**工具设计原则：**

*   **语义化与精确性结合：** 工具设计上兼顾语义搜索（如 `codebase_search`）和精确匹配（如 `grep_search`），以满足不同场景下的信息检索需求。语义搜索用于高层次、模糊的查询，而精确搜索用于已知模式的查找。这种双重设计提供了灵活性和效率。
*   **上下文感知与限制：** 文件读取工具（`read_file`）强调获取完整上下文，但同时限制单次读取量，鼓励分段读取，并对读取整个文件的情况进行严格限制，以优化资源使用。这避免了不必要的资源消耗，并提高了读取效率。
*   **用户批准与安全：** 对于可能影响用户环境的操作（如 `run_terminal_cmd`），工具设计中内置了用户批准机制，确保Agent不会在未经用户同意的情况下执行敏感操作。同时，要求命令包含非交互式标志，以适应自动化环境，并要求 `cd` 到适当目录并进行必要设置，以确保命令在正确的上下文中执行。
*   **操作原子性与效率：** 代码编辑工具（`edit_file`、`search_replace`）强调操作的原子性（如 `search_replace` 每次只替换一个实例）和效率（如 `edit_file` 鼓励在单次调用中完成对一个文件的所有编辑，并支持并行编辑多个文件）。这种设计旨在提高代码修改的精确性和效率。
*   **清晰的意图与解释：** 几乎所有工具都包含 `explanation` 参数，要求Agent说明使用该工具的原因及其对目标贡献。这有助于提高Agent行为的透明度和可解释性，使用户能够理解Agent的决策过程。

**工具使用原则：**

*   **优先使用工具：** 如果信息可通过工具发现，Agent被指导优先使用工具而非询问用户。这鼓励Agent独立解决问题，减少用户干预。
*   **遵循Schema：** Agent必须严格遵循工具调用Schema，并确保提供所有必要的参数。这是确保工具正确执行的基础。
*   **不提及工具名称：** Agent绝不向用户提及工具名称，而是自然地描述操作，以提供更流畅的用户体验。
*   **最大化并行调用：** Agent被明确指示尽可能并行执行工具调用，以最大化效率。除非有特定原因必须顺序执行，否则Agent应始终同时执行多个工具。这与整体效率优化的理念一致。
*   **上下文敏感的搜索策略：** Agent在进行代码搜索时，被指导优先使用 `codebase_search` 进行语义搜索，并从广泛、高层次的查询开始，然后分解为子查询。`grep_search` 则用于精确匹配已知字符串或模式，并要求对特殊字符进行转义。`list_dir` 作为快速发现工具，用于了解文件系统结构，而 `file_search` 用于模糊匹配文件路径。这种多层次的搜索策略确保了Agent能够高效地找到所需信息。
*   **精确的代码编辑：** `edit_file` 在编辑时使用 `// ... existing code ...` 标记未更改的代码区域，以帮助“apply model”正确应用编辑，避免误删。`search_replace` 要求 `old_string` 包含足够的上下文（3-5行前后代码），以确保唯一性和精确替换。这些细节确保了代码修改的精确性和安全性。
*   **健壮性：** 删除文件等操作应设计为即使失败也能优雅处理，不中断Agent流程。这提高了Agent的鲁棒性，使其能够在各种情况下保持稳定运行。

#### 2.2.5 Cursor Agent Prompt 的整体设计理念和核心原则

综合分析上述Prompt文件，Cursor Agent Prompt的设计理念围绕以下几个核心原则展开，旨在构建一个高效、智能、可靠且用户友好的AI Agent：

1.  **明确的角色与目标设定 (Clear Role & Goal Definition):**
    *   **理念:** 每个Agent实例都应有清晰的角色定位（如“AI编码助手”、“软件工程师”）和明确的核心任务目标。这为Agent的行为提供了基础框架和方向。
    *   **实践:** 通过Prompt开头的角色描述和 `<user_query>` 等标签明确Agent的身份和主要职责。

2.  **结构化与模块化指令 (Structured & Modular Instructions):**
    *   **理念:** 将复杂的指令分解为逻辑清晰、模块化的部分，并通过结构化标签进行组织。这提高了Prompt的可读性、可维护性，并有助于模型准确理解和执行不同类型的指令。
    *   **实践:** 广泛使用XML风格的标签（如 `<communication>`, `<tool_calling>`, `<code_style>`）来封装特定领域的规则和指南。

3.  **自主性与持续解决问题 (Autonomy & Persistent Problem Solving):**
    *   **理念:** 赋予Agent高度的自主权，鼓励其在没有明确指示的情况下，主动推进任务直到完全解决。Agent应具备自我驱动和持续迭代的能力。
    *   **实践:** 强调“持续工作直到用户查询完全解决”、“自主解决查询”的原则，并要求Agent在未解决问题前不将控制权交还给用户。

4.  **效率至上 (Efficiency First):**
    *   **理念:** 在Agent的执行过程中，最大化效率是关键。这包括优化信息获取、工具使用和任务流程。
    *   **实践:** 明确指示“最大化并行工具调用”，优先使用高效的工具（如 `codebase_search` 优于 `grep`），并对文件读取等操作进行资源优化。

5.  **精确与透明的沟通 (Precise & Transparent Communication):**
    *   **理念:** Agent与用户之间的沟通应清晰、简洁、精确，并遵循一致的格式规范。同时，Agent的行为应具有一定的透明度，让用户了解其进展和决策。
    *   **实践:** 详细规定Markdown格式、状态更新 (`<status_update_spec>`) 和摘要 (`<summary_spec>`) 的规范，强调使用反引号引用代码/文件，并要求在工具调用时提供 `explanation`。

6.  **健壮的错误处理与自我纠正 (Robust Error Handling & Self-Correction):**
    *   **理念:** Agent应具备识别和处理错误的能力，并在出现偏差时能够进行自我纠正，以提高任务的成功率和可靠性。
    *   **实践:** 包含关于未能遵守规则时进行“自我纠正”的指令，以及在代码更改后检查linter错误和运行测试的流程。

7.  **上下文感知与智能决策 (Context-Awareness & Intelligent Decision Making):**
    *   **理念:** Agent应充分利用所有可用的上下文信息（包括用户状态、文件内容、历史对话等），并基于这些信息做出智能决策，以减少对用户干预的依赖。
    *   **实践:** 鼓励Agent利用语义搜索 (`codebase_search`) 进行探索，优先通过工具获取信息，并提供用户环境信息 (`<user_info>`, `<env>`) 作为决策依据。

8.  **精确的代码操作与风格规范 (Precise Code Operations & Style Guidelines):**
    *   **理念:** 在进行代码相关的操作时，Agent必须确保其更改的精确性、可运行性，并遵循既定的代码风格和最佳实践。
    *   **实践:** 详细规定代码更改的输出格式（如 `// ... existing code ...`）、代码引用方式、以及严格的 `<code_style>` 指南，确保生成的代码质量。

9.  **个性化与记忆管理 (Personalization & Memory Management):**
    *   **理念:** Agent应具备从用户交互中学习并存储长期记忆的能力，以便在未来的对话中提供更个性化和相关的帮助。
    *   **实践:** 通过 `MemoryPrompt` 和 `MemoryRatingPrompt` 建立了记忆的识别、评估和评分机制，确保只有通用、可操作且有价值的用户偏好被记住。

这些原则共同构成了Cursor Agent Prompt设计的基础，旨在创建一个能够高效完成复杂软件工程任务、与用户无缝协作并不断学习进化的AI Agent。





## 3. 高效Agent Prompt设计实践指南

基于对Cursor Agent Prompt设计理念和核心原则的深入分析，本章将提供一份实践指南，帮助Prompt工程师和开发者设计出高效、智能且可靠的Agent Prompt。

### 3.1 明确的角色与目标设定

**核心原则：** 每个Agent都应有清晰的角色定位和明确的核心任务目标，这为其所有行为提供了基础框架和方向。

**实践建议：**

*   **开宗明义：** 在Prompt的开头，使用简洁明了的语言定义Agent的角色、能力和操作环境。例如：“你是一个AI编码助手，由GPT-5驱动，在Cursor中运行。” 这样的描述能迅速为Agent建立上下文。
*   **设定核心目标：** 明确Agent的主要任务，并指出用户指令的入口。使用特定的标签（如 `<user_query>`）来标识用户输入，确保Agent始终聚焦于用户的核心需求。例如：“你的主要目标是遵循用户在每个消息中的指令，由 `<user_query>` 标签表示。”
*   **界定能力范围：** 明确Agent能做什么和不能做什么，避免Agent尝试执行超出其能力范围的任务，从而减少错误和误解。

### 3.2 结构化与模块化指令

**核心原则：** 将复杂的指令分解为逻辑清晰、模块化的部分，并通过结构化标签进行组织，提高Prompt的可读性、可维护性，并有助于模型准确理解和执行不同类型的指令。

**实践建议：**

*   **使用XML风格标签：** 广泛采用XML风格的标签（如 `<communication>`, `<tool_calling>`, `<code_style>`）来封装特定领域的规则和指南。这不仅使Prompt结构清晰，也方便模型识别和处理不同类型的指令块。
*   **指令分块：** 将相关联的指令分组放置在同一个标签内。例如，所有关于Agent与用户沟通的规则都应放在 `<communication>` 标签下，所有关于工具使用的规则都应放在 `<tool_calling>` 标签下。
*   **嵌套与层级：** 对于更复杂的指令，可以考虑使用嵌套标签来创建层级结构，进一步细化指导。例如，`<tool_calling>` 内部可以有关于特定工具的子标签或更详细的规则。
*   **一致性：** 在整个Prompt中保持标签使用和命名的风格一致性，这有助于模型形成稳定的理解模式。

### 3.3 提升Agent自主性与效率

**核心原则：** 赋予Agent高度的自主权，鼓励其在没有明确指示的情况下，主动推进任务直到完全解决。同时，通过优化工具使用和任务流程来最大化效率。

**实践建议：**

*   **强调持续解决问题：** 在Prompt中明确指出Agent应“持续工作直到用户查询完全解决”，并且“自主解决查询”。这鼓励Agent在遇到小问题时自行寻找解决方案，而不是立即寻求用户帮助。
*   **设定完成标准：** 明确任务完成的标志，例如“在确信问题已解决之前，不应终止回合”。这有助于Agent判断何时可以结束当前任务并返回控制权。
*   **最大化并行工具调用：** 明确指示Agent尽可能并行执行工具调用。例如，当需要读取多个文件或执行多个独立的搜索时，应同时调用所有相关工具，而不是顺序执行。这能显著提高任务执行速度。
*   **优先使用工具：** 鼓励Agent优先通过工具获取信息，而非直接询问用户。这减少了用户干预，提高了Agent的独立解决问题能力。例如，在需要了解代码库结构时，优先使用 `codebase_search` 或 `list_dir`。
*   **假设与继续：** 允许Agent在合理范围内做出假设并继续执行，除非遇到真正的阻碍。这避免了Agent因不确定性而频繁暂停，提高了任务的流畅性。

### 3.4 精确与透明的沟通

**核心原则：** Agent与用户之间的沟通应清晰、简洁、精确，并遵循一致的格式规范。同时，Agent的行为应具有一定的透明度，让用户了解其进展和决策。

**实践建议：**

*   **规范Markdown格式：** 详细规定Markdown的使用规范，包括何时使用代码块、反引号、粗体、标题等。例如，文件、目录、函数名使用反引号，关键信息使用粗体，标题使用 `##` 或 `###`。
*   **清晰简洁的语言：** 优化沟通语言，使其清晰、简洁、易于理解。避免使用过于技术化或模糊的表达。例如，将代码更改称为“编辑”而非“补丁”。
*   **提供状态更新：** 要求Agent定期提供简短的状态更新，描述当前正在做什么、已完成什么以及遇到的任何阻碍。状态更新应以对话形式叙述，使用正确的时态，并避免冗余信息。
*   **提供任务摘要：** 在任务完成或回合结束时，提供高层次的更改总结及其影响。摘要应简洁、高信号，不重复计划，并仅在必要时包含代码片段。
*   **工具使用解释：** 在调用工具时，要求Agent提供简短的 `explanation`，说明使用该工具的原因及其对目标贡献。这增加了Agent行为的透明度。
*   **代码引用规范：** 严格规定代码引用格式，例如使用 `startLine:endLine:filepath` 格式引用代码库中的现有代码，并使用带语言标签的围栏代码块表示新代码。

### 3.5 健壮的错误处理与自我纠正

**核心原则：** Agent应具备识别和处理错误的能力，并在出现偏差时能够进行自我纠正，以提高任务的成功率和可靠性。

**实践建议：**

*   **明确错误处理机制：** 在Prompt中定义Agent如何处理不同类型的错误，例如，当未能遵守指令时，应立即进行自我纠正。
*   **代码质量检查：** 在代码更改后，要求Agent检查linter错误并运行测试。如果引入了错误，应优先修复它们，并限制尝试修复的次数，避免陷入循环。
*   **TODO列表管理：** 使用TODO列表来跟踪任务进度，并要求Agent在完成任务或进行状态更新前，及时更新TODO列表。这有助于Agent保持任务的条理性和自我管理。
*   **健壮的工具设计：** 设计工具时应考虑其健壮性，例如，文件删除操作即使失败也能优雅处理，不中断Agent流程。

### 3.6 精确的代码操作与风格规范

**核心原则：** 在进行代码相关的操作时，Agent必须确保其更改的精确性、可运行性，并遵循既定的代码风格和最佳实践。

**实践建议：**

*   **确保代码可运行：** 明确要求Agent生成的代码必须能够立即运行，并包含所有必要的导入、依赖和端点。
*   **代码编辑格式：** 在编辑现有代码时，使用特定的标记（如 `// ... existing code ...`）来表示未更改的代码区域，确保下游自动化工具（如“apply model”）能够精确应用更改，避免误删。
*   **代码风格指南：** 提供详细的代码风格指南（如 `<code_style>` 标签），包括命名约定、静态类型、控制流、注释和格式化等。强调编写高冗余度、清晰可读的代码，并匹配现有代码风格。
*   **避免不必要的输出：** 除非用户明确要求，否则不向用户输出完整的代码，而是使用代码编辑工具直接进行修改。
*   **代码引用规范：** 严格规定代码引用格式，以便用户能够轻松定位和审查代码更改。

### 3.7 个性化与记忆管理

**核心原则：** Agent应具备从用户交互中学习并存储长期记忆的能力，以便在未来的对话中提供更个性化和相关的帮助。

**实践建议：**

*   **记忆识别机制：** 设计Prompt来指导Agent识别对话中值得记忆的信息。这些信息应是通用、可操作且对未来交互有价值的用户偏好、工作流程或技术选择。
*   **记忆评分系统：** 实施一个记忆评分系统，让Agent对潜在记忆进行评估和打分。明确评分标准，例如，强调记忆的通用性、具体性和可操作性，并倾向于低分评分以确保记忆质量。
*   **区分短期与长期记忆：** 明确区分一次性任务细节和可泛化的长期偏好。只有后者才应被存储为记忆。
*   **用户反馈：** 如果用户表达了沮丧或纠正了助手，这些信息特别重要，应被捕获并作为记忆的候选。

## 4. 结论与展望

高效的Agent Prompt设计是构建强大、智能AI Agent的关键。通过对Cursor Agent Prompt案例的深入分析，我们提炼出了一系列核心设计理念和实践准则，涵盖了从角色设定、结构化指令、自主性提升、沟通透明度、错误处理、代码操作到个性化记忆管理等多个方面。

遵循这些指南，开发者和Prompt工程师将能够：

*   **提升Agent性能：** 使Agent更准确地理解任务，更高效地执行操作。
*   **优化用户体验：** 确保Agent与用户的交互更加流畅、自然和富有成效。
*   **增强Agent鲁棒性：** 提高Agent处理复杂情况和从错误中恢复的能力。
*   **实现Agent的个性化与进化：** 赋予Agent学习用户偏好并随着时间推移不断优化的能力。

未来，随着AI技术的不断演进，Agent Prompt的设计也将持续发展。更精细的上下文理解、更强大的自我反思与规划能力、以及更灵活的工具集成将是重要的发展方向。我们鼓励Prompt工程师持续探索和创新，共同推动AI Agent技术迈向新的高度。


